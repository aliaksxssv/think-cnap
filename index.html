<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Cloud Native Application Security Maturity Dashboard</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2306B6D4' stroke-width='2'%3E%3Cpolygon points='12,2 22,8.5 22,15.5 12,22 2,15.5 2,8.5'/%3E%3Cpolygon points='12,6 18,9.5 18,14.5 12,18 6,14.5 6,9.5'/%3E%3Cpolygon points='12,10 15,11.5 15,12.5 12,14 9,12.5 9,11.5'/%3E%3Cline x1='12' y1='2' x2='12' y2='10'/%3E%3Cline x1='12' y1='14' x2='12' y2='22'/%3E%3Cline x1='2' y1='8.5' x2='9' y2='11.5'/%3E%3Cline x1='15' y1='11.5' x2='22' y2='8.5'/%3E%3Cline x1='2' y1='15.5' x2='9' y2='12.5'/%3E%3Cline x1='15' y1='12.5' x2='22' y2='15.5'/%3E%3C/svg%3E"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 70vh;
      min-width: 400px;
    }
    
    .chart-wrapper.single-chart {
      width: 1200px;
      max-width: 95vw;
    }
    
    a.new-window {
      color: darkolivegreen;
      text-decoration: underline;
    }

    .loading-spinner {
      border: 3px solid #374151;
      border-radius: 50%;
      border-top: 3px solid #06B6D4;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 24px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    .notification.success {
      background-color: #10B981;
    }

    .notification.error {
      background-color: #EF4444;
    }

    .notification.warning {
      background-color: #F59E0B;
    }

    .fade-out {
      opacity: 0;
    }

    /* Tooltip styles */
    .tooltip {
      position: relative;
      cursor: help;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 480px;
      background-color: #374151;
      color: #f9fafb;
      text-align: left;
      border-radius: 8px;
      padding: 16px;
      position: fixed;
      z-index: 9999;
      bottom: auto;
      top: auto;
      left: auto;
      right: auto;
      margin: 0;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid #6b7280;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
      font-size: 14px;
      line-height: 1.5;
      pointer-events: auto;
    }

    .tooltip .tooltiptext.show {
      visibility: visible;
      opacity: 1;
    }

    /* Style links and formatting in tooltips */
    .tooltip .tooltiptext a {
      color: #60a5fa;
      text-decoration: underline;
    }

    .tooltip .tooltiptext a:hover {
      color: #93c5fd;
    }

    .tooltip .tooltiptext strong, .tooltip .tooltiptext b {
      font-weight: 600;
      color: #f3f4f6;
    }

    .tooltip .tooltiptext em, .tooltip .tooltiptext i {
      font-style: italic;
      color: #d1d5db;
    }

    .tooltip .tooltiptext code {
      background-color: #374151;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #fbbf24;
    }

    /* Styles for undefined values */
    .undefined-measure {
      background-color: #4B5563 !important;
      color: #9CA3AF !important;
    }

    .undefined-measure select {
      background-color: #6B7280 !important;
      color: #9CA3AF !important;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen p-6">
  <!-- Header with file controls in top right -->
  <div class="flex justify-between items-start mb-3">
    <h1 class="text-3xl font-mono text-cyan-300">Cloud Native Application Security Maturity Dashboard</h1>
    
    <!-- Top right area with controls and notifications -->
    <div class="flex flex-col items-end space-y-2">
      <!-- File controls -->
      <div id="file-loader" class="flex items-center space-x-3">
        <button id="loadScoringBtn" class="bg-cyan-600 hover:bg-cyan-500 px-3 py-2 rounded flex items-center space-x-2 text-sm">
          <span>Load Scoring File</span>
          <div id="loadingScoringSpinner" class="loading-spinner hidden w-4 h-4"></div>
        </button>
        <button id="saveBtn" class="bg-green-600 hover:bg-green-500 px-3 py-2 rounded flex items-center space-x-2 text-sm">
          <span>Save Scoring File</span>
          <div id="saveSpinner" class="loading-spinner hidden w-4 h-4"></div>
        </button>
      </div>
      
      <!-- Notification area below buttons -->
      <div id="top-notification-area" class="min-h-[24px]"></div>
    </div>
  </div>

  <!-- Status message -->
  <div id="status-message" class="mb-1">
    <p id="file-status" class="text-gray-400 text-sm">
      <span id="loading-indicator" class="loading-spinner w-4 h-4 inline-block mr-2"></span>
      Loading controls.yaml automatically...
    </p>
  </div>

  <!-- Main app -->
  <div id="main" class="hidden">
    <div class="flex justify-between items-center mb-6">
      <div id="tabs" class="flex space-x-3 overflow-x-auto"></div>
    </div>
    <div id="panes"></div>
  </div>

<script>
// No embedded data - load from YAML files

class SecurityMaturityDashboard {
    constructor() {
    this.controlsFileHandle = null;
    this.scoringFileHandle = null;
    this.config = null;
    this.scoring = null;
    this.charts = {};
    this.selectedTags = ['aws', 'kubernetes'];
    this.hasUnsavedChanges = false;
    this.controlsLoaded = false;
    this.scoringLoaded = false;

    // Constants
    this.IMPACT_MAP = { low: 1, medium: 2, high: 3 };
    this.EFFORT_MAP = { low: 1, medium: 2, high: 3 };
    this.MATURITY_LEVELS = ['No adoption', 'Ad-hoc', 'Partial', 'Full'];
    
    this.init();
  }

  init() {
    this.bindEvents();
    this.setupBeforeUnloadWarning();
    this.tryLoadControlsFile();
  }

  bindEvents() {
    document.getElementById('loadScoringBtn')?.addEventListener('click', () => this.openScoringFile());
    document.getElementById('saveBtn')?.addEventListener('click', () => this.saveScoringFile());
  }

  async tryLoadControlsFile() {
    // Check if we're running on file:// protocol
    if (window.location.protocol === 'file:') {
      // For local file access, show instructions to use file input
      this.showLocalFileInstructions();
      return;
    }
    
    try {
      // Try to fetch controls.yaml from the same directory (web server only)
      const response = await fetch('./controls.yaml');
      if (response.ok) {
        const text = await response.text();
        this.config = this.parseAndValidateControlsYAML(text);
        this.controlsLoaded = true;
        
        this.updateFileStatus();
        this.showNotification('Controls.yaml loaded automatically!');
        
        // Try to load scoring.yaml automatically as well
        this.tryLoadScoringFile();
      } else {
        throw new Error('controls.yaml not found in same directory');
      }
    } catch (error) {
      // If automatic loading fails, show error and instructions
      this.showControlsLoadingError();
    }
  }

  async tryLoadScoringFile() {
    // Check if we're running on file:// protocol
    if (window.location.protocol === 'file:') {
      // For local file access, try to show the app with default values and let user optionally load scoring
      this.scoring = {}; // Start with empty scoring (will use defaults)
      this.scoringLoaded = false; // Mark as not loaded so user can still load a file
      
      this.mergeControlsWithScoring();
      this.showMainApp();
      this.updateFileStatus();
      this.initApp();
      // No notification needed - user can see the buttons are available
      return;
    }
    
    try {
      // Try to fetch scoring.yaml from the same directory (web server only)
      const response = await fetch('./scoring.yaml');
      if (response.ok) {
        const text = await response.text();
        this.scoring = this.parseAndValidateScoringYAML(text);
        this.scoringLoaded = true;
        
        this.mergeControlsWithScoring();
        this.showMainApp();
        this.updateFileStatus();
        this.initApp();
        this.showNotification('Both controls.yaml and scoring.yaml loaded automatically!');
      } else {
        // Scoring file not found, but that's ok - start with defaults and user can load manually
        this.scoring = {};
        this.scoringLoaded = false;
        
        this.mergeControlsWithScoring();
        this.showMainApp();
        this.updateFileStatus();
        this.initApp();
        // No notification needed - user can see the buttons are available
      }
    } catch (error) {
      // Scoring file loading failed, but that's ok - start with defaults and user can load manually
      this.scoring = {};
      this.scoringLoaded = false;
      
      this.mergeControlsWithScoring();
      this.showMainApp();
      this.updateFileStatus();
      this.initApp();
      // No notification needed - user can see the buttons are available
    }
  }

  showLocalFileInstructions() {
    const statusElement = document.getElementById('file-status');
    const fileLoader = document.getElementById('file-loader');
    
    // Update status for local file access (no message needed)
    statusElement.innerHTML = '';
    statusElement.className = 'text-gray-400 text-sm';
    
    // Add a load controls button for local file access
    const loadControlsBtn = document.createElement('button');
    loadControlsBtn.id = 'loadControlsBtn';
    loadControlsBtn.className = 'bg-blue-600 hover:bg-blue-500 px-3 py-2 rounded flex items-center space-x-2 text-sm';
    loadControlsBtn.innerHTML = `
      <span>Select Controls File</span>
      <div id="loadingControlsSpinner" class="loading-spinner hidden w-4 h-4"></div>
    `;
    
    // Insert the button at the beginning
    fileLoader.insertBefore(loadControlsBtn, fileLoader.firstChild);
    
    // Add click handler
    loadControlsBtn.addEventListener('click', () => this.openControlsFile());
    
    // No notification needed for local file mode
  }

  async openControlsFile() {
    try {
      this.showLoading('loadingControlsSpinner');
      
      // Check if File System Access API is supported
      if (window.showOpenFilePicker) {
        // Modern API approach
        [this.controlsFileHandle] = await window.showOpenFilePicker({
          types: [{
            description: 'Controls YAML files',
            accept: {
              'text/yaml': ['.yaml', '.yml'],
              'text/plain': ['.yaml', '.yml']
            }
          }],
          multiple: false
        });

        const file = await this.controlsFileHandle.getFile();
        const text = await file.text();
        this.config = this.parseAndValidateControlsYAML(text);
        this.controlsLoaded = true;
        
        this.hideLoading('loadingControlsSpinner');
        
        // Remove the temporary load controls button
        const loadControlsBtn = document.getElementById('loadControlsBtn');
        if (loadControlsBtn) {
          loadControlsBtn.remove();
        }
        
        this.updateFileStatus();
        this.showNotification('Controls file loaded successfully!');
        
        // For local file mode, don't try to auto-load scoring - user needs to select it
        this.updateFileStatus();
      } else {
        // Fallback to traditional file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.yaml,.yml';
        
        input.onchange = async (e) => {
          try {
            const file = e.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            this.config = this.parseAndValidateControlsYAML(text);
            this.controlsFileHandle = null;
            this.controlsLoaded = true;
            this.hideLoading('loadingControlsSpinner');
            
            // Remove the temporary load controls button
            const loadControlsBtn = document.getElementById('loadControlsBtn');
            if (loadControlsBtn) {
              loadControlsBtn.remove();
            }
            
            this.updateFileStatus();
            this.showNotification('Controls file loaded successfully!');
          } catch (error) {
            this.hideLoading('loadingControlsSpinner');
            this.showNotification(`Error loading controls file: ${error.message}`, 'error');
          }
        };
        
        input.click();
      }
      
    } catch (error) {
      this.hideLoading('loadingControlsSpinner');
      if (error.message !== 'File selection cancelled') {
        this.showNotification(`Error loading controls file: ${error.message}`, 'error');
        console.error('Controls file loading error:', error);
      }
    }
  }

  showControlsLoadingError() {
    const statusElement = document.getElementById('file-status');
    
    // Update status to show error
    statusElement.innerHTML = '❌ ERROR: controls.yaml must be in the same directory as this HTML file';
    statusElement.className = 'text-red-400 text-sm font-semibold';
    
    // Disable all buttons since we can't proceed without controls
    document.getElementById('loadScoringBtn').disabled = true;
    document.getElementById('saveBtn').disabled = true;
    
    this.showNotification('ERROR: controls.yaml file must be placed in the same directory as index-standalone.html', 'error');
  }

  updateFileStatus() {
    const statusElement = document.getElementById('file-status');
    const loadingIndicator = document.getElementById('loading-indicator');
    const loadScoringBtn = document.getElementById('loadScoringBtn');
    const saveBtn = document.getElementById('saveBtn');
    
    if (!this.controlsLoaded) {
      statusElement.innerHTML = '<span id="loading-indicator" class="loading-spinner w-4 h-4 inline-block mr-2"></span>Loading controls.yaml automatically...';
      statusElement.className = 'text-yellow-400 text-sm';
      loadScoringBtn.disabled = true;
      saveBtn.disabled = true;
    } else if (!this.scoringLoaded) {

      statusElement.className = 'text-cyan-400 text-sm';
      loadScoringBtn.disabled = false;
      saveBtn.disabled = true;
    } else {
      statusElement.textContent = 'Both files loaded successfully! Dashboard is ready.';
      statusElement.className = 'text-green-400 text-sm';
      loadScoringBtn.disabled = false;
      saveBtn.disabled = false;
    }
  }

  showMainApp() {
    document.getElementById('status-message').classList.add('hidden');
    document.getElementById('main').classList.remove('hidden');
  }



  parseAndValidateControlsYAML(text) {
    try {
      const controls = jsyaml.load(text);
      
      // Validate structure
      if (!controls.security_domains || !Array.isArray(controls.security_domains)) {
        throw new Error('Invalid controls YAML structure: missing or invalid security_domains array');
      }

      return controls;
    } catch (error) {
      throw new Error(`Controls YAML parsing failed: ${error.message}`);
    }
  }

  async openScoringFile() {
    try {
      this.showLoading('loadingScoringSpinner');
      
      // Check if File System Access API is supported
      if (window.showOpenFilePicker) {
        // Modern API approach
        [this.scoringFileHandle] = await window.showOpenFilePicker({
          types: [{
            description: 'Scoring YAML files',
            accept: {
              'text/yaml': ['.yaml', '.yml'],
              'text/plain': ['.yaml', '.yml']
            }
          }],
          multiple: false
        });

        const file = await this.scoringFileHandle.getFile();
        const text = await file.text();
        this.scoring = this.parseAndValidateScoringYAML(text);
        this.scoringLoaded = true;
        
        this.hideLoading('loadingScoringSpinner');
        this.updateFileStatus();
        this.hasUnsavedChanges = false;
        
        // If controls are already loaded, merge and init app
        if (this.controlsLoaded) {
          this.mergeControlsWithScoring();
          this.showMainApp();
          this.initApp();
          this.showNotification('Scoring file loaded successfully! Dashboard is ready.');
        } else {
          this.showNotification('Scoring file loaded! Please load controls.yaml next.');
        }
      } else {
        // Fallback to traditional file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.yaml,.yml';
        
        input.onchange = async (e) => {
          try {
            const file = e.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            this.scoring = this.parseAndValidateScoringYAML(text);
            this.scoringFileHandle = null;
            this.scoringLoaded = true;
            this.hideLoading('loadingScoringSpinner');
            this.updateFileStatus();
            this.hasUnsavedChanges = false;
            
            // If controls are already loaded, merge and init app
            if (this.controlsLoaded) {
              this.mergeControlsWithScoring();
              this.showMainApp();
              this.initApp();
              this.showNotification('Scoring file loaded successfully! Dashboard is ready.');
            } else {
              this.showNotification('Scoring file loaded! Please load controls.yaml next.');
            }
          } catch (error) {
            this.hideLoading('loadingScoringSpinner');
            this.showNotification(`Error loading scoring file: ${error.message}`, 'error');
          }
        };
        
        input.click();
      }
      
    } catch (error) {
      this.hideLoading('loadingScoringSpinner');
      if (error.message !== 'File selection cancelled') {
        this.showNotification(`Error loading scoring file: ${error.message}`, 'error');
        console.error('Scoring file loading error:', error);
      }
    }
  }

  setupBeforeUnloadWarning() {
    window.addEventListener('beforeunload', (e) => {
      if (this.hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
  }

  showNotification(message, type = 'success') {
    const topNotificationArea = document.getElementById('top-notification-area');
    if (topNotificationArea) {
      // Show notification in top right area above buttons
      const notification = document.createElement('div');
      const colorClass = type === 'error' ? 'text-red-400' : 
                        type === 'warning' ? 'text-yellow-400' : 
                        type === 'info' ? 'text-cyan-400' : 'text-green-400';
      notification.className = `${colorClass} text-xs text-right`;
      notification.textContent = message;
      
      // Clear any existing notification
      topNotificationArea.innerHTML = '';
      topNotificationArea.appendChild(notification);
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (topNotificationArea.contains(notification)) {
          topNotificationArea.innerHTML = '';
        }
      }, 3000);
    } else {
      // Fallback to original notification system
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
  }

  showLoading(elementId) {
    const spinner = document.getElementById(elementId);
    if (spinner) {
      spinner.classList.remove('hidden');
    }
  }

  hideLoading(elementId) {
    const spinner = document.getElementById(elementId);
    if (spinner) {
      spinner.classList.add('hidden');
    }
  }

  parseAndValidateScoringYAML(text) {
    try {
      const scoring = jsyaml.load(text);
      
      // Validate structure
      if (!scoring.measures || typeof scoring.measures !== 'object') {
        throw new Error('Invalid scoring YAML structure: missing or invalid measures object');
      }

      return scoring;
    } catch (error) {
      throw new Error(`Scoring YAML parsing failed: ${error.message}`);
    }
  }

  mergeControlsWithScoring() {
    if (!this.config || !this.scoring) return;
    
    // Iterate through all action items and merge with scoring data
    this.config.security_domains.forEach(domain => {
      domain.security_controls.forEach(control => {
        control.action_items.forEach(actionItem => {
          const measureId = actionItem.measure_id;
          const scoreData = this.scoring.measures[measureId];
          
          if (scoreData) {
            // Merge scoring data with action item
            actionItem.impact = scoreData.impact || 'undefined';
            actionItem.effort = scoreData.effort || 'undefined';
            actionItem.before = scoreData.before !== undefined ? scoreData.before : 'undefined';
            actionItem.maturity = scoreData.maturity !== undefined ? scoreData.maturity : 'undefined';
            actionItem.goal = scoreData.goal !== undefined ? scoreData.goal : 'undefined';
          } else {
            // No scoring data found - set default undefined values
            actionItem.impact = 'undefined';
            actionItem.effort = 'undefined';
            actionItem.before = 'undefined';
            actionItem.maturity = 'undefined';
            actionItem.goal = 'undefined';
          }
        });
      });
    });
  }

  async saveScoringFile() {
    try {
      this.showLoading('saveSpinner');
      
      // Generate scoring data from current state
      const scoringData = { measures: {} };
      
      this.config.security_domains.forEach(domain => {
        domain.security_controls.forEach(control => {
          control.action_items.forEach(actionItem => {
            if (actionItem.measure_id) {
              scoringData.measures[actionItem.measure_id] = {
                impact: actionItem.impact,
                effort: actionItem.effort,
                before: actionItem.before,
                maturity: actionItem.maturity,
                goal: actionItem.goal
              };
            }
          });
        });
      });
      
      const yamlText = jsyaml.dump(scoringData, {
        indent: 2,
        lineWidth: 120,
        noRefs: true
      });
      
      if (window.showSaveFilePicker) {
        try {
          // First, let user browse to see existing files (optional step)
          const shouldBrowse = await this.askUserToBrowseFirst();
          let directoryHandle = null;
          
          if (shouldBrowse) {
            try {
              // Let user pick a directory to see existing files
              directoryHandle = await window.showDirectoryPicker();
            } catch (dirError) {
              // User cancelled directory picker, continue with normal save
              console.log('Directory picker cancelled, using normal save dialog');
            }
          }
          
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: 'scoring.yaml',
            startIn: directoryHandle || 'documents',
            types: [{
              description: 'Scoring YAML files',
              accept: {
                'text/yaml': ['.yaml', '.yml'],
                'text/plain': ['.yaml', '.yml']
              }
            }]
          });
          
          const writable = await fileHandle.createWritable();
          await writable.write(yamlText);
          await writable.close();
          
          this.scoringFileHandle = fileHandle;
          this.hasUnsavedChanges = false;
          this.hideLoading('saveSpinner');
          this.showNotification('Scoring file saved successfully!');
        } catch (saveError) {
          if (saveError.name === 'AbortError') {
            this.hideLoading('saveSpinner');
            return; // User cancelled
          }
          throw saveError;
        }
      } else {
        // Fallback - create download link
        const blob = new Blob([yamlText], { type: 'text/yaml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'scoring.yaml';
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.hasUnsavedChanges = false;
        this.hideLoading('saveSpinner');
        this.showNotification('Scoring file downloaded successfully!');
      }
      
    } catch (error) {
      this.hideLoading('saveSpinner');
      if (error.message !== 'File selection cancelled') {
        this.showNotification(`Error saving scoring file: ${error.message}`, 'error');
        console.error('Save error:', error);
      }
    }
  }

  async askUserToBrowseFirst() {
    return new Promise((resolve) => {
      // Create a simple dialog to ask user if they want to browse first
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-gray-800 p-6 rounded-lg max-w-md mx-4">
          <h3 class="text-xl font-semibold text-white mb-4">Save Scoring File</h3>
          <p class="text-gray-300 mb-6">Would you like to browse to a specific folder first to see existing files?</p>
          <div class="flex space-x-4">
            <button id="browseFirstBtn" class="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded text-white">
              Browse First
            </button>
            <button id="saveDirectlyBtn" class="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded text-white">
              Save Directly
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      document.getElementById('browseFirstBtn').onclick = () => {
        document.body.removeChild(modal);
        resolve(true);
      };
      
      document.getElementById('saveDirectlyBtn').onclick = () => {
        document.body.removeChild(modal);
        resolve(false);
      };
      
      // Close on background click
      modal.onclick = (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          resolve(false);
        }
      };
    });
  }

  calculateWeight(actionItem) {
    // Skip items with undefined values
    if (actionItem.impact === 'undefined' || actionItem.effort === 'undefined') {
      return 0;
    }
    const impact = this.IMPACT_MAP[actionItem.impact] || 1;
    const effort = this.EFFORT_MAP[actionItem.effort] || 1;
    return impact / effort;
  }

  calculateDomainField(domain, field, tags = null) {
    let items = (domain.security_controls || []).flatMap(control => control.action_items || []);
    
    // Filter by tags if specified
    if (tags && tags.length > 0) {
      items = items.filter(item => {
        const itemTag = item.tags;
        return tags.includes(itemTag);
      });
    } else if (tags && tags.length === 0) {
      // No tags selected, no items should be included
      items = [];
    }
    
    // Filter out items with ANY undefined values
    items = items.filter(item => {
      return item.impact !== 'undefined' && 
             item.effort !== 'undefined' && 
             item.before !== 'undefined' && 
             item.maturity !== 'undefined' && 
             item.goal !== 'undefined' &&
             item.before !== undefined && 
             item.maturity !== undefined && 
             item.goal !== undefined;
    });
    
    if (items.length === 0) return 0;

    const weights = items.map(item => this.calculateWeight(item));
    const scores = items.map(item => (item[field] || 0) * this.calculateWeight(item));
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    
    return totalWeight ? scores.reduce((sum, score) => sum + score, 0) / totalWeight : 0;
  }

  filterActionItemsByTags(actionItems, tags) {
    if (!tags || tags.length === 0) return [];
    const filtered = actionItems.filter(item => {
      const itemTag = item.tags;
      return tags.includes(itemTag);
    });
    return filtered;
  }

  updateTagSelection() {
    const checkboxes = document.querySelectorAll('.tag-filter');
    this.selectedTags = Array.from(checkboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);
    
    // Force refresh all domain panes
    this.refreshAllPanes();
    
    this.updateChartsDisplay();
    this.drawCharts();
  }

  refreshAllPanes() {
    const domains = this.config.security_domains || [];
    
    domains.forEach((domain, index) => {
      const slugName = this.createSlug(domain.name);
      const oldPane = document.getElementById(`pane-${slugName}`);
      
      if (oldPane) {
        const newPane = this.createDomainPane(domain, index);
        
        // Preserve the visibility state
        const isVisible = !oldPane.classList.contains('hidden');
        if (isVisible) {
          newPane.classList.remove('hidden');
        }
        
        if (oldPane.parentNode) {
          oldPane.parentNode.replaceChild(newPane, oldPane);
        }
      }
    });
  }

  updateChartsDisplay() {
    const awsChart = document.getElementById('chart-aws');
    const kubernetesChart = document.getElementById('chart-kubernetes');
    const container = document.getElementById('charts-container');
    
    const showAws = this.selectedTags.includes('aws');
    const showKubernetes = this.selectedTags.includes('kubernetes');
    
    awsChart.classList.toggle('hidden', !showAws);
    kubernetesChart.classList.toggle('hidden', !showKubernetes);
    
    // Center single chart with larger size using CSS classes
    if (showAws && !showKubernetes) {
      container.className = 'flex justify-center';
      awsChart.classList.add('single-chart');
      kubernetesChart.classList.remove('single-chart');
    } else if (!showAws && showKubernetes) {
      container.className = 'flex justify-center';
      kubernetesChart.classList.add('single-chart');
      awsChart.classList.remove('single-chart');
    } else if (showAws && showKubernetes) {
      container.className = 'flex justify-center space-x-8';
      awsChart.classList.remove('single-chart');
      kubernetesChart.classList.remove('single-chart');
    }
    
    // Trigger chart resize after layout change
    setTimeout(() => {
      if (this.charts.aws && showAws) {
        this.charts.aws.resize();
      }
      if (this.charts.kubernetes && showKubernetes) {
        this.charts.kubernetes.resize();
      }
    }, 100);
  }

  createSlug(text) {
    return text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  }

  drawCharts() {
    const domains = this.config.security_domains;

    // Draw AWS chart if selected
    if (this.selectedTags.includes('aws')) {
      const filteredData = this.filterDomainsWithData(domains, ['aws']);
      if (filteredData.domains.length > 0) {
        this.drawSingleChart('aws', filteredData.labels, filteredData.domains, ['aws']);
      } else {
        this.clearChart('aws');
      }
    }

    // Draw Kubernetes chart if selected
    if (this.selectedTags.includes('kubernetes')) {
      const filteredData = this.filterDomainsWithData(domains, ['kubernetes']);
      if (filteredData.domains.length > 0) {
        this.drawSingleChart('kubernetes', filteredData.labels, filteredData.domains, ['kubernetes']);
      } else {
        this.clearChart('kubernetes');
      }
    }
  }

  filterDomainsWithData(domains, filterTags) {
    const filteredDomains = domains.filter(domain => {
      // Check if this domain has any action items matching the filter tags
      const hasMatchingItems = (domain.security_controls || []).some(control => {
        return (control.action_items || []).some(item => {
          return filterTags.includes(item.tags);
        });
      });
      return hasMatchingItems;
    });

    return {
      domains: filteredDomains,
      labels: filteredDomains.map(domain => domain.name)
    };
  }

  clearChart(tag) {
    if (this.charts[tag]) {
      this.charts[tag].destroy();
      this.charts[tag] = null;
    }
  }

  drawSingleChart(tag, labels, domains, filterTags) {
    const ctx = document.getElementById(`radar-${tag}`)?.getContext('2d');
    if (!ctx) return;

    const beforeData = domains.map(domain => this.calculateDomainField(domain, 'before', filterTags));
    const nowData = domains.map(domain => this.calculateDomainField(domain, 'maturity', filterTags));
    const goalData = domains.map(domain => this.calculateDomainField(domain, 'goal', filterTags));

    // Destroy existing chart
    if (this.charts[tag]) {
      this.charts[tag].destroy();
    }

    // Color schemes for different tags
    const colorSchemes = {
      aws: {
        before: { bg: 'rgba(54, 162, 235, 0.2)', border: 'rgba(54, 162, 235, 0.8)' },
        now: { bg: 'rgba(255, 99, 132, 0.2)', border: 'rgba(255, 99, 132, 0.8)' },
        goal: { bg: 'rgba(255, 205, 86, 0.2)', border: 'rgba(255, 205, 86, 0.8)' }
      },
      kubernetes: {
        before: { bg: 'rgba(54, 162, 235, 0.2)', border: 'rgba(54, 162, 235, 0.8)' },
        now: { bg: 'rgba(255, 99, 132, 0.2)', border: 'rgba(255, 99, 132, 0.8)' },
        goal: { bg: 'rgba(255, 205, 86, 0.2)', border: 'rgba(255, 205, 86, 0.8)' }
      }
    };

    const colors = colorSchemes[tag];

    this.charts[tag] = new Chart(ctx, {
      type: 'radar',
      data: {
        labels,
        datasets: [
          {
            label: 'Before',
            data: beforeData,
            fill: true,
            backgroundColor: colors.before.bg,
            borderColor: colors.before.border,
            borderWidth: 2,
            pointBackgroundColor: colors.before.border
          },
          {
            label: 'Now',
            data: nowData,
            fill: true,
            backgroundColor: colors.now.bg,
            borderColor: colors.now.border,
            borderWidth: 2,
            pointBackgroundColor: colors.now.border
          },
          {
            label: 'Goal',
            data: goalData,
            fill: true,
            backgroundColor: colors.goal.bg,
            borderColor: colors.goal.border,
            borderWidth: 2,
            pointBackgroundColor: colors.goal.border
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          r: {
            min: 0,
            max: 3,
            ticks: {
              stepSize: 1,
              color: '#06B6D4'
            },
            grid: {
              color: 'rgba(6, 182, 212, 0.2)'
            },
            angleLines: {
              color: 'rgba(6, 182, 212, 0.3)'
            },
            pointLabels: {
              color: '#38BDF8',
              font: {
                size: 12
              }
            }
          }
        },
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              color: '#22D3EE'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(17, 24, 39, 0.9)',
            titleColor: '#06B6D4',
            bodyColor: '#E5E7EB'
          }
        }
      }
    });
  }

  createOptionElements(options, selectedValue, valueKey = null, useIndices = false) {
    return options.map((option, index) => {
      // Handle 'undefined' option specially
      if (option === 'undefined') {
        const selected = selectedValue === 'undefined' ? ' selected' : '';
        return `<option value="undefined"${selected}>Undefined</option>`;
      }
      
      // Use indices when explicitly requested (for maturity levels), otherwise use string values for string arrays
      let value;
      if (valueKey) {
        value = option[valueKey];
      } else if (useIndices) {
        // For maturity levels: first real option (after 'undefined') should be 0
        value = index - 1; // 'undefined' is at index 0, so 'No adoption' at index 1 becomes value 0
      } else {
        value = typeof option === 'string' ? option : index;
      }
      
      const label = typeof option === 'string' ? option : option.label || option;
      const selected = selectedValue === value ? ' selected' : '';
      return `<option value="${value}"${selected}>${label}</option>`;
    }).join('');
  }

  createDomainPane(domain, domainIndex) {
    const slugName = this.createSlug(domain.name);
    const pane = document.createElement('div');
    pane.id = `pane-${slugName}`;
    pane.className = 'hidden';

    // Check if both tags are selected to show separate scores
    const showBothTags = this.selectedTags.includes('aws') && this.selectedTags.includes('kubernetes');
    const noTagsSelected = this.selectedTags.length === 0;
    
    let scoresHtml = '';
    
    if (noTagsSelected) {
      // No tags selected - show message
      scoresHtml = `
        <div class="space-x-4 font-semibold">
          <span class="text-gray-400">No tags selected - please select AWS and/or Kubernetes tags to view maturity scores</span>
        </div>
      `;
    } else if (showBothTags) {
      // Calculate separate scores for AWS and Kubernetes
      const awsBeforeScore = this.calculateDomainField(domain, 'before', ['aws']).toFixed(2);
      const awsNowScore = this.calculateDomainField(domain, 'maturity', ['aws']).toFixed(2);
      const awsGoalScore = this.calculateDomainField(domain, 'goal', ['aws']).toFixed(2);
      
      const k8sBeforeScore = this.calculateDomainField(domain, 'before', ['kubernetes']).toFixed(2);
      const k8sNowScore = this.calculateDomainField(domain, 'maturity', ['kubernetes']).toFixed(2);
      const k8sGoalScore = this.calculateDomainField(domain, 'goal', ['kubernetes']).toFixed(2);
      
      scoresHtml = `
        <div class="space-y-3 font-semibold">
          <div class="space-x-4">
            <span class="text-cyan-300">AWS:</span>
            <span id="domain-aws-before-${domainIndex}" style="color:rgba(54,162,235,0.8)">
              Before: ${awsBeforeScore} / 3
            </span>
            <span id="domain-aws-now-${domainIndex}" style="color:rgba(255,99,132,0.8)">
              Now: ${awsNowScore} / 3
            </span>
            <span id="domain-aws-goal-${domainIndex}" style="color:rgba(255,205,86,0.8)">
              Goal: ${awsGoalScore} / 3
            </span>
          </div>
          <div class="space-x-4">
            <span class="text-cyan-300">Kubernetes:</span>
            <span id="domain-k8s-before-${domainIndex}" style="color:rgba(54,162,235,0.8)">
              Before: ${k8sBeforeScore} / 3
            </span>
            <span id="domain-k8s-now-${domainIndex}" style="color:rgba(255,99,132,0.8)">
              Now: ${k8sNowScore} / 3
            </span>
            <span id="domain-k8s-goal-${domainIndex}" style="color:rgba(255,205,86,0.8)">
              Goal: ${k8sGoalScore} / 3
            </span>
          </div>
        </div>
      `;
    } else {
      // Single tag selected - show combined score
      const beforeScore = this.calculateDomainField(domain, 'before', this.selectedTags).toFixed(2);
      const nowScore = this.calculateDomainField(domain, 'maturity', this.selectedTags).toFixed(2);
      const goalScore = this.calculateDomainField(domain, 'goal', this.selectedTags).toFixed(2);
      
      const tagName = this.selectedTags.includes('aws') ? 'AWS' : 
                     this.selectedTags.includes('kubernetes') ? 'Kubernetes' : 'Combined';
      
      scoresHtml = `
        <div class="space-x-4 font-semibold">
          <span class="text-cyan-300">${tagName}:</span>
          <span id="domain-before-${domainIndex}" style="color:rgba(54,162,235,0.8)">
            Before: ${beforeScore} / 3
          </span>
          <span id="domain-now-${domainIndex}" style="color:rgba(255,99,132,0.8)">
            Now: ${nowScore} / 3
          </span>
          <span id="domain-goal-${domainIndex}" style="color:rgba(255,205,86,0.8)">
            Goal: ${goalScore} / 3
          </span>
        </div>
      `;
    }

    let html = `
      <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-4 space-y-2 md:space-y-0">
        ${scoresHtml}
      </div>
      <div class="overflow-x-auto">
        <table class="table-fixed w-full border-collapse mb-8">
          <thead>
            <tr class="bg-gray-800">
              <th class="border border-gray-600 p-3 text-left w-[32%]">Security Measure</th>
              <th class="border border-gray-600 p-3 text-left w-[23%]">MITRE ATT&CK TTP</th>
              <th class="border border-gray-600 p-3 text-left w-[9%]">Impact</th>
              <th class="border border-gray-600 p-3 text-left w-[9%]">Effort</th>
              <th class="border border-gray-600 p-3 text-left w-[9%]">Before</th>
              <th class="border border-gray-600 p-3 text-left w-[9%]">Now</th>
              <th class="border border-gray-600 p-3 text-left w-[9%]">Goal</th>
            </tr>
          </thead>
          <tbody>
    `;

    (domain.security_controls || []).forEach((control, controlIndex) => {
      // Filter action items by selected tags
      const filteredActionItems = this.filterActionItemsByTags(control.action_items || [], this.selectedTags);
      
      // Only show control if it has filtered action items
      if (filteredActionItems.length > 0) {
        html += `
          <tr class="bg-gray-800">
            <td colspan="7" class="border border-gray-600 p-3 font-mono text-cyan-300 break-words">
              ${this.escapeHtml(control.code || 'N/A')}: ${this.escapeHtml(control.text || 'No description')}
            </td>
          </tr>
        `;

        filteredActionItems.forEach((actionItem, actionIndex) => {
          // Find original action index for data binding
          const originalActionIndex = (control.action_items || []).indexOf(actionItem);
          
          // Check if this measure has undefined values
          const hasUndefinedValues = actionItem.impact === 'undefined' || 
                                   actionItem.effort === 'undefined' || 
                                   actionItem.before === 'undefined' || 
                                   actionItem.maturity === 'undefined' || 
                                   actionItem.goal === 'undefined';
          
          const rowClass = hasUndefinedValues ? 'hover:bg-gray-800 transition-colors undefined-measure' : 'hover:bg-gray-800 transition-colors';

          // Display tags
          const tagsDisplay = actionItem.tags ? actionItem.tags : '';
          const measureId = actionItem.measure_id || 'No ID';

          // Prepare measure text with optional tooltip
          let measureContent = actionItem.measure || 'No measure specified';
          if (actionItem.comment) {
            measureContent = `
              <div class="tooltip">
                <span>${measureContent}</span>
                <span class="tooltiptext">${this.sanitizeCommentHtml(actionItem.comment)}</span>
              </div>
            `;
          }

          html += `
            <tr class="${rowClass}">
              <td class="border border-gray-600 p-3 break-words">
                ${measureContent}
                <div class="text-xs text-gray-500 mt-1">ID: ${measureId}</div>
                ${tagsDisplay ? `<div class="text-xs text-cyan-400 mt-1">Tag: ${tagsDisplay}</div>` : ''}
                ${hasUndefinedValues ? '<div class="text-xs text-yellow-400 mt-1">⚠️ Undefined values - excluded from calculations</div>' : ''}
              </td>
              <td class="border border-gray-600 p-3 break-words">${this.createMitreLink(actionItem.mitre)}</td>
              <td class="border border-gray-600 p-3">
                <select 
                  data-di="${domainIndex}" 
                  data-ci="${controlIndex}" 
                  data-ai="${originalActionIndex}" 
                  data-prop="impact" 
                  class="bg-gray-700 text-gray-200 p-2 rounded w-full focus:ring-2 focus:ring-cyan-500 focus:outline-none"
                >
                  ${this.createOptionElements(['undefined', 'low', 'medium', 'high'], actionItem.impact)}
                </select>
              </td>
              <td class="border border-gray-600 p-3">
                <select 
                  data-di="${domainIndex}" 
                  data-ci="${controlIndex}" 
                  data-ai="${originalActionIndex}" 
                  data-prop="effort" 
                  class="bg-gray-700 text-gray-200 p-2 rounded w-full focus:ring-2 focus:ring-cyan-500 focus:outline-none"
                >
                  ${this.createOptionElements(['undefined', 'low', 'medium', 'high'], actionItem.effort)}
                </select>
              </td>
              <td class="border border-gray-600 p-3">
                <select 
                  data-di="${domainIndex}" 
                  data-ci="${controlIndex}" 
                  data-ai="${originalActionIndex}" 
                  data-prop="before" 
                  class="bg-gray-700 text-gray-200 p-2 rounded w-full focus:ring-2 focus:ring-cyan-500 focus:outline-none"
                >
                  ${this.createOptionElements(['undefined', ...this.MATURITY_LEVELS], actionItem.before, null, true)}
                </select>
              </td>
              <td class="border border-gray-600 p-3">
                <select 
                  data-di="${domainIndex}" 
                  data-ci="${controlIndex}" 
                  data-ai="${originalActionIndex}" 
                  data-prop="maturity" 
                  class="bg-gray-700 text-gray-200 p-2 rounded w-full focus:ring-2 focus:ring-cyan-500 focus:outline-none"
                >
                  ${this.createOptionElements(['undefined', ...this.MATURITY_LEVELS], actionItem.maturity, null, true)}
                </select>
              </td>
              <td class="border border-gray-600 p-3">
                <select 
                  data-di="${domainIndex}" 
                  data-ci="${controlIndex}" 
                  data-ai="${originalActionIndex}" 
                  data-prop="goal" 
                  class="bg-gray-700 text-gray-200 p-2 rounded w-full focus:ring-2 focus:ring-cyan-500 focus:outline-none"
                >
                  ${this.createOptionElements(['undefined', ...this.MATURITY_LEVELS], actionItem.goal, null, true)}
                </select>
              </td>
            </tr>
          `;
        });
      }
    });

    html += '</tbody></table></div>';
    pane.innerHTML = html;
    
    // Add tooltip event listeners
    this.setupTooltips(pane);
    
    return pane;
  }

  setupTooltips(container) {
    const tooltips = container.querySelectorAll('.tooltip');
    tooltips.forEach(tooltip => {
      const tooltipText = tooltip.querySelector('.tooltiptext');
      if (!tooltipText) return;

      let hideTimeout;

      const showTooltip = () => {
        // Clear any pending hide timeout
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }

        const rect = tooltip.getBoundingClientRect();
        
        // Calculate position
        let top = rect.top - tooltipText.offsetHeight - 10;
        let left = rect.left + (rect.width / 2) - (480 / 2); // 480px is tooltip width
        
        // Adjust if tooltip goes off screen
        if (left < 10) left = 10;
        if (left + 480 > window.innerWidth - 10) left = window.innerWidth - 490;
        if (top < 10) top = rect.bottom + 10;
        
        tooltipText.style.top = `${top}px`;
        tooltipText.style.left = `${left}px`;
        tooltipText.classList.add('show');
      };

      const hideTooltip = () => {
        // Add a small delay before hiding to allow moving to tooltip
        hideTimeout = setTimeout(() => {
          tooltipText.classList.remove('show');
        }, 100);
      };

      const cancelHide = () => {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
      };

      // Trigger element events
      tooltip.addEventListener('mouseenter', showTooltip);
      tooltip.addEventListener('mouseleave', hideTooltip);

      // Tooltip events
      tooltipText.addEventListener('mouseenter', cancelHide);
      tooltipText.addEventListener('mouseleave', hideTooltip);
    });
  }

  // Transform MITRE value to clickable link
  createMitreLink(mitreValue) {
    if (!mitreValue || mitreValue === 'undefined' || mitreValue === 'N/A') {
      return this.escapeHtml(mitreValue || 'N/A');
    }
    
    // Parse MITRE value: tactic:technique/subtechnique
    const parts = mitreValue.split(':');
    if (parts.length !== 2) {
      // Fallback for malformed MITRE values
      const sanitizedMitre = mitreValue.replace(/[:/]/g, '_').toLowerCase();
      const linkPath = `https://thinkcnap.org/mitre/${sanitizedMitre}.html`;
      return `<a href="${linkPath}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${this.escapeHtml(mitreValue)}</a>`;
    }
    
    const tactic = parts[0].trim().toLowerCase();
    const technique = parts[1].trim().replace(/\//g, '_').toLowerCase(); // Replace / with _ and convert to lowercase
    const linkPath = `https://thinkcnap.org/mitre/${tactic}/${technique}.html`
    
    return `<a href="${linkPath}" target="_blank" class="text-blue-400 hover:text-blue-300 underline">${this.escapeHtml(mitreValue)}</a>`;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  sanitizeCommentHtml(text) {
    if (!text) return '';
    
    // Allow specific HTML tags for formatting
    const allowedTags = ['br', 'a', 'strong', 'b', 'em', 'i', 'u', 'code', 'span'];
    const allowedAttributes = ['href', 'target', 'class'];
    
    // Create a temporary div to parse HTML
    const div = document.createElement('div');
    div.innerHTML = text;
    
    // Function to clean nodes recursively
    const cleanNode = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        return node.textContent;
      }
      
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        
        if (allowedTags.includes(tagName)) {
          let result = `<${tagName}`;
          
          // Add allowed attributes
          for (let attr of node.attributes) {
            if (allowedAttributes.includes(attr.name.toLowerCase())) {
              result += ` ${attr.name}="${attr.value}"`;
            }
          }
          
          if (tagName === 'br') {
            result += ' />';
          } else {
            result += '>';
            for (let child of node.childNodes) {
              result += cleanNode(child);
            }
            result += `</${tagName}>`;
          }
          
          return result;
        } else {
          // If tag is not allowed, just return its text content
          return node.textContent;
        }
      }
      
      return '';
    };
    
    let result = '';
    for (let child of div.childNodes) {
      result += cleanNode(child);
    }
    
    return result;
  }

  handleInputChange(event) {
    const element = event.target;
    const { di, ci, ai, prop } = element.dataset;
    
    if (di === undefined) return;

    const domainIndex = parseInt(di);
    const controlIndex = parseInt(ci);
    const actionIndex = parseInt(ai);
    
    const actionItem = this.config.security_domains[domainIndex]
      .security_controls[controlIndex]
      .action_items[actionIndex];

    // Update the data
    if (['impact', 'effort'].includes(prop)) {
      actionItem[prop] = element.value;
    } else {
      if (element.value === 'undefined') {
        actionItem[prop] = 'undefined';
      } else {
        actionItem[prop] = parseInt(element.value);
      }
    }

    this.hasUnsavedChanges = true;
    
    // Update row styling based on undefined values
    const row = element.closest('tr');
    const hasUndefinedValues = actionItem.impact === 'undefined' || 
                             actionItem.effort === 'undefined' || 
                             actionItem.before === 'undefined' || 
                             actionItem.maturity === 'undefined' || 
                             actionItem.goal === 'undefined';
    
    if (hasUndefinedValues) {
      row.classList.add('undefined-measure');
    } else {
      row.classList.remove('undefined-measure');
    }
    
    this.updateDomainScores(domainIndex);
    
    // Update chart if dashboard is visible
    const dashboardPane = document.getElementById('pane-dashboard');
    if (dashboardPane && !dashboardPane.classList.contains('hidden')) {
      this.drawCharts(); // Refresh all charts
    }
  }

  updateDomainScores(domainIndex) {
    const domain = this.config.security_domains[domainIndex];
    
    // Check if both tags are selected to show separate scores
    const showBothTags = this.selectedTags.includes('aws') && this.selectedTags.includes('kubernetes');
    const noTagsSelected = this.selectedTags.length === 0;
    
    if (noTagsSelected) {
      return;
    }

    if (showBothTags) {
      // Update separate scores for AWS and Kubernetes
      const awsBefore = document.getElementById(`domain-aws-before-${domainIndex}`);
      const awsNow = document.getElementById(`domain-aws-now-${domainIndex}`);
      const awsGoal = document.getElementById(`domain-aws-goal-${domainIndex}`);
      
      if (awsBefore) awsBefore.textContent = `Before: ${this.calculateDomainField(domain, 'before', ['aws']).toFixed(2)} / 3`;
      if (awsNow) awsNow.textContent = `Now: ${this.calculateDomainField(domain, 'maturity', ['aws']).toFixed(2)} / 3`;
      if (awsGoal) awsGoal.textContent = `Goal: ${this.calculateDomainField(domain, 'goal', ['aws']).toFixed(2)} / 3`;

      const k8sBefore = document.getElementById(`domain-k8s-before-${domainIndex}`);
      const k8sNow = document.getElementById(`domain-k8s-now-${domainIndex}`);
      const k8sGoal = document.getElementById(`domain-k8s-goal-${domainIndex}`);
      
      if (k8sBefore) k8sBefore.textContent = `Before: ${this.calculateDomainField(domain, 'before', ['kubernetes']).toFixed(2)} / 3`;
      if (k8sNow) k8sNow.textContent = `Now: ${this.calculateDomainField(domain, 'maturity', ['kubernetes']).toFixed(2)} / 3`;
      if (k8sGoal) k8sGoal.textContent = `Goal: ${this.calculateDomainField(domain, 'goal', ['kubernetes']).toFixed(2)} / 3`;
    } else {
      // Single tag selected - update combined score
      const beforeScore = this.calculateDomainField(domain, 'before', this.selectedTags).toFixed(2);
      const nowScore = this.calculateDomainField(domain, 'maturity', this.selectedTags).toFixed(2);
      const goalScore = this.calculateDomainField(domain, 'goal', this.selectedTags).toFixed(2);

      const beforeElement = document.getElementById(`domain-before-${domainIndex}`);
      const nowElement = document.getElementById(`domain-now-${domainIndex}`);
      const goalElement = document.getElementById(`domain-goal-${domainIndex}`);

      if (beforeElement) beforeElement.textContent = `Before: ${beforeScore} / 3`;
      if (nowElement) nowElement.textContent = `Now: ${nowScore} / 3`;
      if (goalElement) goalElement.textContent = `Goal: ${goalScore} / 3`;
    }
  }

  activateTab(slugName) {
    const tabs = document.querySelectorAll('[id^="tab-"]');
    const panes = document.querySelectorAll('[id^="pane-"]');

    tabs.forEach(tab => {
      const isActive = tab.id === `tab-${slugName}`;
      tab.classList.toggle('border-b-2', isActive);
      tab.classList.toggle('border-cyan-400', isActive);
      tab.classList.toggle('text-cyan-300', isActive);
      tab.classList.toggle('text-gray-400', !isActive);
    });

    panes.forEach(pane => {
      const isActive = pane.id === `pane-${slugName}`;
      pane.classList.toggle('hidden', !isActive);
    });

    if (slugName === 'dashboard') {
      // Small delay to ensure the canvas is visible
      setTimeout(() => this.drawCharts(), 100);
    }
  }

  initApp() {
    const domains = this.config.security_domains || [];
    const tabsElement = document.getElementById('tabs');
    const panesElement = document.getElementById('panes');
    
    // Clear existing content
    tabsElement.innerHTML = '';
    panesElement.innerHTML = '';

    // Create dashboard pane
    const dashboardPane = document.createElement('div');
    dashboardPane.id = 'pane-dashboard';
    dashboardPane.innerHTML = `
      <div class="mb-6">
        <!-- Tag Selection -->
        <div class="mb-6 p-4 bg-gray-800 rounded-lg">

          <div class="flex space-x-6">
            <label class="flex items-center space-x-2 cursor-pointer">
              <input type="checkbox" id="tag-aws" class="tag-filter" value="aws" checked>
              <span class="text-gray-200">AWS</span>
            </label>
            <label class="flex items-center space-x-2 cursor-pointer">
              <input type="checkbox" id="tag-kubernetes" class="tag-filter" value="kubernetes" checked>
              <span class="text-gray-200">Kubernetes</span>
            </label>
          </div>
        </div>
        
        <!-- Charts Container -->
        <div id="charts-container" class="flex justify-center space-x-8">
          <div id="chart-aws" class="chart-wrapper hidden">
            <h3 class="text-lg font-semibold mb-2 text-center text-cyan-300">AWS</h3>
            <canvas id="radar-aws"></canvas>
          </div>
          <div id="chart-kubernetes" class="chart-wrapper hidden">
            <h3 class="text-lg font-semibold mb-2 text-center text-cyan-300">Kubernetes</h3>
            <canvas id="radar-kubernetes"></canvas>
          </div>
        </div>
      </div>
    `;
    panesElement.appendChild(dashboardPane);

    // Create domain panes
    domains.forEach((domain, index) => {
      const pane = this.createDomainPane(domain, index);
      panesElement.appendChild(pane);
    });

    // Set up event delegation for input changes
    panesElement.addEventListener('input', (e) => this.handleInputChange(e));
    panesElement.addEventListener('change', (e) => this.handleInputChange(e));

    // Set up tag filter event listeners
    document.addEventListener('change', (e) => {
      if (e.target.classList.contains('tag-filter')) {
        this.updateTagSelection();
      }
    });

    // Create tabs
    const tabs = [
      { name: 'Dashboard', slug: 'dashboard' },
      ...domains.map(domain => ({
        name: domain.name,
        slug: this.createSlug(domain.name)
      }))
    ];

    tabs.forEach((tab, index) => {
      const button = document.createElement('button');
      button.id = `tab-${tab.slug}`;
      button.textContent = tab.name;
      button.className = 'px-4 py-2 cursor-pointer hover:text-cyan-400 transition-colors whitespace-nowrap';
      button.onclick = () => this.activateTab(tab.slug);
      tabsElement.appendChild(button);

      // Activate first tab (Dashboard)
      if (index === 0) {
        this.activateTab(tab.slug);
      }
    });

    // Initialize charts display and draw initial charts
    setTimeout(() => {
      this.updateChartsDisplay();
      this.drawCharts();
    }, 100);
  }
}

// Initialize the application
const dashboard = new SecurityMaturityDashboard();
</script>

</body>
</html>
